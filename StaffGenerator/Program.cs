using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Aspects;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Order;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading.Tasks;

namespace StaffGenerator
{
    record StaffData(IBookGetter Book, ISpellGetter Spell, string SpellName, string SpellEditorID, MagicSchool MagisSchool, MagicLevel MagicLevel, IWeaponGetter UnenchantedStaff, int HeartStoneCount, ushort EnchantmentAmount)
    {
        public string? EnchantmentEditorID;
        public IObjectEffectGetter? Enchantment;

        public bool EnchantmentExisted = true;

        public string? StaffEditorID;
        public IWeaponGetter? Staff;

        public bool StaffExisted = true;
    }

    enum MagicSchool
    {
        Alteration,
        Conjuration,
        Destruction,
        Illusion,
        Restoration
    };

    enum MagicLevel
    {
        Novice = 0,
        Apprentice = 25,
        Adept = 50,
        Expert = 75,
        Master = 100
    };

    public partial class Program
    {
        static Lazy<Settings> Settings = null!;
        private readonly Lazy<Settings> settings;
        private readonly ILoadOrder<IModListing<ISkyrimModGetter>> LoadOrder;
        private readonly ILinkCache<ISkyrimMod, ISkyrimModGetter> LinkCache;
        private readonly ISkyrimMod PatchMod;

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings
                )
                .SetTypicalOpen(GameRelease.SkyrimSE, "YourPatcher.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            new Program(state.LoadOrder, state.LinkCache, state.PatchMod, Settings).RunPatch();
        }

        public Program(ILoadOrder<IModListing<ISkyrimModGetter>> loadOrder, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache, ISkyrimMod patchMod, Lazy<Settings> settings)
        {
            LoadOrder = loadOrder;
            LinkCache = linkCache;
            PatchMod = patchMod;
            this.settings = settings;
        }

        private static readonly Dictionary<IFormLinkGetter<IPerkGetter>, HashSet<IFormLink<ILeveledItemGetter>>> HalfCostPerkIDToLevelledListIDs = new()
        {
            { Skyrim.Perk.AlterationApprentice25, new() { Skyrim.LeveledItem.LItemStaffAlteration25 } },
            { Skyrim.Perk.AlterationExpert75, new() { Skyrim.LeveledItem.LItemStaffAlteration75 } },
            { Skyrim.Perk.ConjurationNovice00, new() { Skyrim.LeveledItem.LItemStaffConjuration00, Skyrim.LeveledItem.LItemStaffConjuration00NPC } },
            { Skyrim.Perk.ConjurationApprentice25, new() { Skyrim.LeveledItem.LItemStaffConjuration25, Skyrim.LeveledItem.LItemStaffConjuration25NPC } },
            { Skyrim.Perk.ConjurationAdept50, new() { Skyrim.LeveledItem.LItemStaffConjuration50, Skyrim.LeveledItem.LItemStaffConjuration50NPC } },
            { Skyrim.Perk.ConjurationExpert75, new() { Skyrim.LeveledItem.LItemStaffConjuration75, Skyrim.LeveledItem.LItemStaffConjuration75NPC } },
            { Skyrim.Perk.DestructionNovice00, new() { Skyrim.LeveledItem.LItemStaffDestruction00 } },
            { Skyrim.Perk.DestructionApprentice25, new() { Skyrim.LeveledItem.LItemStaffDestruction25, Skyrim.LeveledItem.LItemStaffDestruction25NPC50 } },
            { Skyrim.Perk.DestructionAdept50, new() { Skyrim.LeveledItem.LItemStaffDestruction50, Skyrim.LeveledItem.LItemStaffDestruction50NPC50 } },
            { Skyrim.Perk.DestructionExpert75, new() { Skyrim.LeveledItem.LItemStaffDestruction75 } },
            { Skyrim.Perk.IllusionNovice00, new() { Skyrim.LeveledItem.LItemStaffIllusion00 } },
            { Skyrim.Perk.IllusionApprentice25, new() { Skyrim.LeveledItem.LItemStaffIllusion25 } },
            { Skyrim.Perk.IllusionAdept50, new() { Skyrim.LeveledItem.LItemStaffIllusion50 } },
            { Skyrim.Perk.IllusionExpert75, new() { Skyrim.LeveledItem.LItemStaffIllusion75 } },
            { Skyrim.Perk.RestorationApprentice25, new() { Skyrim.LeveledItem.LItemStaffRestoration25 } },
            { Skyrim.Perk.RestorationAdept50, new() { Skyrim.LeveledItem.LItemStaffRestoration50 } },
            { Skyrim.Perk.RestorationExpert75, new() { Skyrim.LeveledItem.LItemStaffRestoration75 } },
        };

        private static readonly Dictionary<IFormLinkGetter<IPerkGetter>, (MagicSchool school, MagicLevel level)> HalfCostPerkIDToMagicSchoolAndLevel = new()
        {
            { Skyrim.Perk.AlterationNovice00, (MagicSchool.Alteration, MagicLevel.Novice) },
            { Skyrim.Perk.AlterationApprentice25, (MagicSchool.Alteration, MagicLevel.Apprentice) },
            { Skyrim.Perk.AlterationAdept50, (MagicSchool.Alteration, MagicLevel.Adept) },
            { Skyrim.Perk.AlterationExpert75, (MagicSchool.Alteration, MagicLevel.Expert) },
            { Skyrim.Perk.ConjurationNovice00, (MagicSchool.Conjuration, MagicLevel.Novice) },
            { Skyrim.Perk.ConjurationApprentice25, (MagicSchool.Conjuration, MagicLevel.Apprentice) },
            { Skyrim.Perk.ConjurationAdept50, (MagicSchool.Conjuration, MagicLevel.Adept) },
            { Skyrim.Perk.ConjurationExpert75, (MagicSchool.Conjuration, MagicLevel.Expert) },
            { Skyrim.Perk.DestructionNovice00, (MagicSchool.Destruction, MagicLevel.Novice) },
            { Skyrim.Perk.DestructionApprentice25, (MagicSchool.Destruction, MagicLevel.Apprentice) },
            { Skyrim.Perk.DestructionAdept50, (MagicSchool.Destruction, MagicLevel.Adept) },
            { Skyrim.Perk.DestructionExpert75, (MagicSchool.Destruction, MagicLevel.Expert) },
            { Skyrim.Perk.IllusionNovice00, (MagicSchool.Illusion, MagicLevel.Novice) },
            { Skyrim.Perk.IllusionApprentice25, (MagicSchool.Illusion, MagicLevel.Apprentice) },
            { Skyrim.Perk.IllusionAdept50, (MagicSchool.Illusion, MagicLevel.Adept) },
            { Skyrim.Perk.IllusionExpert75, (MagicSchool.Illusion, MagicLevel.Expert) },
            { Skyrim.Perk.RestorationNovice00, (MagicSchool.Restoration, MagicLevel.Novice) },
            { Skyrim.Perk.RestorationApprentice25, (MagicSchool.Restoration, MagicLevel.Apprentice) },
            { Skyrim.Perk.RestorationAdept50, (MagicSchool.Restoration, MagicLevel.Adept) },
            { Skyrim.Perk.RestorationExpert75, (MagicSchool.Restoration, MagicLevel.Expert) },
        };

        private static readonly Dictionary<MagicLevel, (int heartStoneCount, ushort enchantmentAmount)> MagicLevelToStaffData = new()
        {
            { MagicLevel.Novice, (1, 500) },
            { MagicLevel.Apprentice, (2, 1000) },
            { MagicLevel.Adept, (3, 2000) },
            { MagicLevel.Expert, (4, 3000) },
            { MagicLevel.Master, (5, 4000) },
        };

        private static readonly HashSet<CastType> AllowedCastTypes = new()
        {
            CastType.Concentration,
            CastType.FireAndForget
        };

        private static readonly HashSet<IFormLinkGetter<IEquipTypeGetter>> AllowedEquipmentTypes = new()
        {
            Skyrim.EquipType.EitherHand,
            Skyrim.EquipType.LeftHand,
            Skyrim.EquipType.RightHand
        };

        private static readonly HashSet<Condition.Function> conditionFunctionsAlwaysFalseUsingAStaff = new()
        {
            Condition.Function.EffectWasDualCast,
            Condition.Function.IsDualCasting,
        };

        private static readonly HashSet<Condition.Function> playerOnlyConditionFunctions = new()
        {
            Condition.Function.IsPCAMurderer,
            Condition.Function.GetPCExpelled,
            Condition.Function.GetPCFactionMurder,
            Condition.Function.GetPCEnemyofFaction,
            Condition.Function.GetPCFactionAttack,
            Condition.Function.GetVATSMode,
            Condition.Function.GetPCMiscStat,
        };

        private static readonly Dictionary<Condition.Function, Condition.Function> playerSpecificToCasterConditionFunctions = new()
        {
            { Condition.Function.GetPCIsClass, Condition.Function.GetIsClass },
            { Condition.Function.GetPCIsRace, Condition.Function.GetIsRace },
            { Condition.Function.GetPCIsSex, Condition.Function.GetIsSex },
            { Condition.Function.GetPCInFaction, Condition.Function.GetInFaction },
            { Condition.Function.SameFactionAsPC, Condition.Function.SameFaction },
            { Condition.Function.SameRaceAsPC, Condition.Function.SameRace },
            { Condition.Function.SameSexAsPC, Condition.Function.SameSex },
        };

        private static readonly Dictionary<IFormLinkGetter<IWeaponGetter>, MagicSchool> UnenchantedStaffIDByMagicSchool = new()
        {
            { Skyrim.Weapon.StaffTemplateAlteration, MagicSchool.Alteration },
            { Skyrim.Weapon.StaffTemplateConjuration, MagicSchool.Conjuration },
            { Skyrim.Weapon.StaffTemplateDestruction, MagicSchool.Destruction },
            { Skyrim.Weapon.StaffTemplateIIllusion, MagicSchool.Illusion },
            { Skyrim.Weapon.StaffTemplateRestoration, MagicSchool.Restoration },
        };

        public void RunPatch()
        {
            IndexStaffEnchantments(
                LoadOrder.PriorityOrder.ObjectEffect().WinningOverrides(),
                out var staffEnchantmentsByEditorID,
                out var staffEnchantmentsByMagicEffect);

            IndexWeapons(
                LoadOrder.PriorityOrder.Weapon().WinningOverrides(),
                out var staves,
                out var stavesByEditorID,
                out var unenchantedStavesByMagicSchool,
                out var enchantedStavesByEnchantment);

            var recipesByCreatedStaff = IndexRecipies(LoadOrder.PriorityOrder.ConstructibleObject().WinningOverrides(), staves);

            IndexLeveledLists(
                LoadOrder.PriorityOrder.LeveledItem().WinningOverrides(),
                out var leveledListsByFormKey,
                out var leveledListsByEditorID);

            Func<IWeaponGetter, int, ExtendedList<ContainerEntry>> makeNewRecipeIngredients = (unenchantedStaff, heartStoneCount) => new()
            {
                new()
                {
                    Item = new()
                    {
                        Item = unenchantedStaff.AsLink<IItemGetter>(),
                        Count = 1
                    }
                },
                new()
                {
                    Item = new()
                    {
                        Item = Dragonborn.MiscItem.DLC2HeartStone,
                        Count = heartStoneCount
                    }
                }
            };

            makeNewRecipeIngredients = makeNewRecipeIngredients.Memoize();

            var stavesData = new List<StaffData>();

            foreach (var book in LoadOrder.PriorityOrder.Book().WinningOverrides())
            {
                if (settings.Value.SpellBooksNotToCreateStavesFor.Contains(book)) continue;
                if (book.Teaches is not IBookSpellGetter spellBook) continue;

                if (!spellBook.Spell.TryResolve(LinkCache, out var spell)) continue;
                if (settings.Value.SpellsNotToCreateStavesFor.Contains(spell)) continue;

                if (spell.Name is null) continue;
                if (spell.Name.String is null) continue;
                var spellName = spell.Name.String;
                if (spell.EditorID is null) continue;
                var spellEditorID = spell.EditorID;
                if (spell.Type != SpellType.Spell) continue;
                if (spell.TargetType == TargetType.Self) continue;
                if (!AllowedCastTypes.Contains(spell.CastType)) continue;
                if (!AllowedEquipmentTypes.Contains(spell.EquipmentType)) continue;

                var halfCostPerkID = spell.HalfCostPerk;

                if (!HalfCostPerkIDToMagicSchoolAndLevel.TryGetValue(halfCostPerkID, out var magicSchoolAndLevel)) continue;

                var (magicSchool, magicLevel) = magicSchoolAndLevel;

                if (!MagicLevelToStaffData.TryGetValue(magicLevel, out var staffData)) continue;

                if (!unenchantedStavesByMagicSchool.TryGetValue(magicSchool, out var unenchantedStaff)) continue;

                stavesData.Add(new StaffData(book, spell, spellName, spellEditorID, magicSchool, magicLevel, unenchantedStaff, staffData.heartStoneCount, staffData.enchantmentAmount));
            }

            var claimedEnchantments = new HashSet<IObjectEffectGetter>();

            foreach (var staffData in stavesData)
            {
                staffData.EnchantmentEditorID = "StaffEnch" + staffData.SpellEditorID;

                if (staffEnchantmentsByEditorID.TryGetValue(staffData.EnchantmentEditorID, out staffData.Enchantment))
                    claimedEnchantments.Add(staffData.Enchantment);
            }

            IEnumerable<Effect> spellToStaffEffects(StaffData staffData)
            {
                // TODO filter and/or modify conditions.
                return staffData.Spell.Effects.Where(x => !x.BaseEffect.IsNull).Select(x => x.DeepCopy());
            }

            foreach (var staffData in stavesData)
            {
                if (staffData.Enchantment is not null) continue;

                var candidateEnchantments = new Dictionary<IObjectEffectGetter, int>();

                foreach (var magicEffect in staffData.Spell.Effects)
                {
                    var baseEffect = magicEffect.BaseEffect;
                    if (baseEffect.IsNull) continue;
                    if (staffEnchantmentsByMagicEffect.TryGetValue(baseEffect, out var candidateEnchantments1))
                    {
                        foreach (var candidateEnchantment in candidateEnchantments1)
                        {
                            if (claimedEnchantments.Contains(candidateEnchantment)) continue;
                            candidateEnchantments.TryGetValue(candidateEnchantment, out var count);
                            candidateEnchantments[candidateEnchantment] = count + 1;
                        }
                    }
                }

                foreach (var candidateEnchantment in candidateEnchantments.OrderBy(x => x.Value))
                {
                    // TODO how do we pick the right one?
                    staffData.Enchantment = candidateEnchantment.Key;
                    claimedEnchantments.Add(candidateEnchantment.Key);
                    break;
                }

                if (staffData.Enchantment is not null)
                {
                    if (candidateEnchantments.Count > 1)
                    {
                        Console.WriteLine($"For the spell {PrettyPrintMajorRecord(staffData.Spell)},");
                        Console.WriteLine($"selected {PrettyPrintMajorRecord(staffData.Enchantment)} from the other possibilities:");
                        foreach (var (candidateEnchanement, count) in candidateEnchantments)
                            if (candidateEnchanement != staffData.Enchantment)
                                Console.WriteLine(PrettyPrintMajorRecord(candidateEnchanement));
                        Console.WriteLine();
                    }
                    continue;
                }

                var newEnchantment = PatchMod.ObjectEffects.AddNew(staffData.EnchantmentEditorID);
                newEnchantment.Name = staffData.SpellName;
                newEnchantment.CastType = staffData.Spell.CastType;
                newEnchantment.TargetType = staffData.Spell.TargetType;
                newEnchantment.EnchantType = ObjectEffect.EnchantTypeEnum.StaffEnchantment;
                newEnchantment.Effects.AddRange(spellToStaffEffects(staffData));

                staffData.EnchantmentExisted = false;

                staffData.Enchantment = newEnchantment;
            }

            if (settings.Value.CopySpellEffectsToExistingStaffEnchantments)
                foreach (var staffData in stavesData)
                {
                    if (staffData.Enchantment is null) throw new NullReferenceException(); // Can't happen.
                    if (!staffData.EnchantmentExisted) continue;
                    if (settings.Value.StaffEnchantmentsNotToRefresh.Contains(staffData.Enchantment)) continue;

                    var enchantment = staffData.Enchantment;
                    var modifiedEnchantment = enchantment.DeepCopy();

                    bool modified = false;

                    if (modifiedEnchantment.Name != staffData.SpellName)
                    {
                        modifiedEnchantment.Name = staffData.SpellName;
                        modified = true;
                    }

                    if (modifiedEnchantment.CastType != staffData.Spell.CastType)
                    {
                        modifiedEnchantment.CastType = staffData.Spell.CastType;
                        modified = true;
                    }

                    if (modifiedEnchantment.TargetType != staffData.Spell.TargetType)
                    {
                        modifiedEnchantment.TargetType = staffData.Spell.TargetType;
                        modified = true;
                    }

                    var newEffects = spellToStaffEffects(staffData);

                    if (!modifiedEnchantment.Effects.Equals(newEffects))
                    {
                        modifiedEnchantment.Effects.Clear();
                        modifiedEnchantment.Effects.AddRange(newEffects);
                        modified = true;
                    }

                    if (modified)
                    {
                        PatchMod.ObjectEffects.Set(modifiedEnchantment);
                        staffData.Enchantment = modifiedEnchantment;
                    }
                }

            var claimedStaves = new HashSet<IWeaponGetter>();

            foreach (var staffData in stavesData)
            {
                staffData.StaffEditorID = "Staff" + staffData.SpellEditorID;

                if (stavesByEditorID.TryGetValue(staffData.StaffEditorID, out staffData.Staff))
                    claimedStaves.Add(staffData.Staff);
            }

            var newStavesByHalfCostPerk = new Dictionary<IFormLinkGetter<IPerkGetter>, List<IWeapon>>();

            foreach (var staffData in stavesData)
            {
                if (staffData.Staff is not null) continue;
                if (staffData.Enchantment is null)
                    throw new NullReferenceException("Can't happen");

                if (enchantedStavesByEnchantment.TryGetValue(staffData.Enchantment.AsLink(), out var candidateStaves))
                {
                    var unenchantedStaffLink = staffData.UnenchantedStaff.AsLink();

                    var filteredCandidates = (
                        from candidateStaff in candidateStaves
                        where !claimedStaves.Contains(candidateStaff)
                        where candidateStaff.Template == unenchantedStaffLink
                        select candidateStaff
                    ).ToList();

                    foreach (var candidateStaff in filteredCandidates)
                    {
                        if (candidateStaff.EditorID?.Equals(staffData.StaffEditorID, StringComparison.OrdinalIgnoreCase) != true) continue;
                        claimedStaves.Add(candidateStaff);
                        staffData.Staff = candidateStaff;
                        break;
                    }

                    if (staffData.Staff is null)
                        foreach (var candidateStaff in filteredCandidates)
                        {
                            // TODO add more criteria?
                            claimedStaves.Add(candidateStaff);
                            staffData.Staff = candidateStaff;
                            break;
                        }

                    if (staffData.Staff is not null && filteredCandidates.Count > 1)
                    {
                        Console.WriteLine($"For the spell {PrettyPrintMajorRecord(staffData.Spell)},");
                        Console.WriteLine($"Selected {PrettyPrintMajorRecord(staffData.Staff)} from the other possibilities:");
                        foreach (var candidateStaff in filteredCandidates)
                            if (candidateStaff != staffData.Staff)
                                Console.WriteLine(PrettyPrintMajorRecord(candidateStaff));
                        Console.WriteLine();
                    }
                }

                if (staffData.Staff is not null)
                {
                    continue;
                }

                var newStaff = PatchMod.Weapons.AddNew(staffData.StaffEditorID);
                staffData.StaffExisted = false;
                newStaff.DeepCopyIn(staffData.UnenchantedStaff, new Weapon.TranslationMask(true)
                {
                    EditorID = false,
                    Name = false,
                    Template = false,
                    ObjectEffect = false,
                    EnchantmentAmount = false
                });

                newStaff.Name = settings.Value.StaffNamePrefix + staffData.SpellName + settings.Value.StaffNameSuffix;
                newStaff.Template.SetTo(staffData.UnenchantedStaff);
                newStaff.ObjectEffect.SetTo(staffData.Enchantment);
                newStaff.EnchantmentAmount = staffData.EnchantmentAmount;
                if (settings.Value.SetStaffPriceToSpellBookPrice)
                    (newStaff.BasicStats ??= new()).Value = staffData.Book.Value;

                var modifiedQAStaffContainer = new Lazy<IContainer>(() => PatchMod.Containers.GetOrAddAsOverride(Skyrim.Container.QAStaffContainer.Resolve(LinkCache)));

                (modifiedQAStaffContainer.Value.Items ??= new()).Add(new()
                {
                    Item = new()
                    {
                        Item = newStaff.AsLink<IItemGetter>(),
                        Count = 1
                    }
                });

                newStavesByHalfCostPerk.Autovivify(staffData.Spell.HalfCostPerk).Add(newStaff);

                staffData.Staff = newStaff;
            }

            foreach (var staffData in stavesData)
            {
                if (staffData.Staff is null)
                    throw new NullReferenceException("Can't happen");

                if (!staffData.StaffExisted) continue;

                if (!(settings.Value.OverrideNamesOfExistingStaves || settings.Value.SetStaffPriceToSpellBookPrice)) continue;

                var modifiedStaff = PatchMod.Weapons.GetOrAddAsOverride(staffData.Staff);

                if (settings.Value.OverrideNamesOfExistingStaves)
                    modifiedStaff.Name = settings.Value.StaffNamePrefix + staffData.SpellName + settings.Value.StaffNameSuffix;

                if (settings.Value.SetStaffPriceToSpellBookPrice)
                    (modifiedStaff.BasicStats ??= new()).Value = staffData.Book.Value;

                staffData.Staff = modifiedStaff;
            }

            foreach (var staffData in stavesData)
            {
                if (staffData.Staff is null)
                    throw new NullReferenceException("Can't happen");
                if (settings.Value.StavesToNotRefreshRecipesFor.Contains(staffData.Staff)) continue;

                IConstructibleObject newRecipe;
                if (recipesByCreatedStaff.TryGetValue(staffData.Staff.AsLink(), out var oldRrecipe))
                    newRecipe = PatchMod.ConstructibleObjects.GetOrAddAsOverride(oldRrecipe);
                else
                    newRecipe = PatchMod.ConstructibleObjects.AddNew("DLC2Recipe" + staffData.StaffEditorID);

                newRecipe.Items = makeNewRecipeIngredients(staffData.UnenchantedStaff, staffData.HeartStoneCount);

                newRecipe.Conditions.Clear();
                newRecipe.Conditions.Add(new ConditionFloat()
                {
                    CompareOperator = CompareOperator.EqualTo,
                    ComparisonValue = 1,
                    Data = new FunctionConditionData()
                    {
                        Function = Condition.Function.HasSpell,
                        ParameterOneRecord = staffData.Spell.AsLink<ISkyrimMajorRecordGetter>(),
                        Unknown2 = 0,
                        RunOnType = Condition.RunOnType.Reference,
                        Reference = Constants.Player.AsSetter(),
                        Unknown3 = -1
                    }
                });
                newRecipe.CreatedObject.SetTo(staffData.Staff);
                newRecipe.WorkbenchKeyword.SetTo(Dragonborn.Keyword.DLC2StaffEnchanter);
                newRecipe.CreatedObjectCount = 1;
            }

            var leveledListByMagicLevel = new Dictionary<MagicLevel, ILeveledItem>();
            var modifiedLeveledListByFormKey = new Dictionary<FormKey, ILeveledItem>();

            // TODO add found staves if they're not in already in the leveled lists?
            foreach (var (halfCostPerkID, newStaves) in newStavesByHalfCostPerk)
            {
                var (magicSchool, magicLevel) = HalfCostPerkIDToMagicSchoolAndLevel[halfCostPerkID];

                if (newStaves.Count > 1)
                    Console.WriteLine($"Adding {newStaves.Count} new {magicLevel} {magicSchool} staves to the appropriate leveled lists.");
                else
                    Console.WriteLine($"Adding {newStaves.Count} new {magicLevel} {magicSchool} staff to the appropriate leveled lists.");

                var leveledLists = new HashSet<ILeveledItemGetter>();
                var modifiedLeveledLists = new List<ILeveledItem>();

                if (HalfCostPerkIDToLevelledListIDs.TryGetValue(halfCostPerkID, out var leveledListIDs))
                    leveledLists.UnionWith(leveledListIDs.Select(x => leveledListsByFormKey[x]));

                var magicLevelString = String.Format("{0:D2}", (int)magicLevel);

                var leveledListEditorID = $"LItemStaff{magicSchool:g}{magicLevelString}";
                if (leveledListsByEditorID.TryGetValue(leveledListEditorID, out var leveledList))
                    leveledLists.Add(leveledList);
                else
                {
                    var newLeveledList = PatchMod.LeveledItems.AddNew(leveledListEditorID);
                    newLeveledList.ChanceNone = 0;
                    newLeveledList.Flags = LeveledItem.Flag.CalculateForEachItemInCount | LeveledItem.Flag.CalculateFromAllLevelsLessThanOrEqualPlayer;

                    (leveledListByMagicLevel.Autovivify(magicLevel, () => PatchMod.LeveledItems.GetOrAddAsOverride(leveledListsByEditorID[$"LItemStaff{magicLevelString}"])).Entries ??= new()).Add(new()
                    {
                        Data = new()
                        {
                            Level = 1,
                            Reference = newLeveledList.AsLink<IItemGetter>(),
                            Count = 1,
                        }
                    });

                    modifiedLeveledLists.Add(newLeveledList);
                }

                foreach (var leveledList2 in leveledLists)
                    modifiedLeveledLists.Add(modifiedLeveledListByFormKey.Autovivify(leveledList2.FormKey, () => PatchMod.LeveledItems.GetOrAddAsOverride(leveledList2)));

                var leveledItems = newStaves.Select(staff => new LeveledItemEntry()
                {
                    Data = new()
                    {
                        Level = 1,
                        Reference = staff.AsLink<IItemGetter>(),
                        Count = 1,
                    }
                }).ToList();

                foreach (var leveledList3 in modifiedLeveledLists)
                    (leveledList3.Entries ??= new()).AddRange(leveledItems);
            }
        }

        private static string PrettyPrintMajorRecord(IMajorRecordGetter record)
        {
            if (record is INamedGetter hasName)
                return $"{record.EditorID} \"{hasName.Name}\" {record.FormKey}";
            return $"{record.EditorID} {record.FormKey}";
        }
    }
}
